
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Tutorial &#8212; charmonium.cache 1.2.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Features" href="features.html" />
    <link rel="prev" title="Frequently Asked Questions" href="faq.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<section id="how-to-use">
<h2>How to Use<a class="headerlink" href="#how-to-use" title="Permalink to this headline">¶</a></h2>
<p>First you need to identify candidates for memoization.</p>
<ul class="simple">
<li><p>They should be <em>language-level</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Pure_function">pure</a>. Global variables are ok, but
system-level global state is not (e.g. setting <code class="docutils literal notranslate"><span class="pre">os.environ</span></code>).</p></li>
<li><p>File IO operations should be done through <code class="docutils literal notranslate"><span class="pre">FileContents</span></code> (see
below). Alternatively, do the File IO in a wrapper function around a pure
inner function.</p></li>
<li><p>Likewise, The function and those it depends on should be relatively
stable. This library can only safely use cached values over subsequent
processes if the source code of those functions does not change.</p></li>
<li><p>The function should have a high rate of reused arguments.</p></li>
<li><p>The returned value should have a low data storage size.</p></li>
<li><p>The function should have a long compute time, so memoization can save a lot of
work.</p></li>
</ul>
<p>Note that multiple functions are cached in the same backend store. This way, a
good candidate for memoization can “steal space” from bad candidates, as long as
the replacement policy is decent.</p>
<p>Once you have your candidate, simply add <a class="reference internal" href="api_reference.html#charmonium.cache.memoize" title="charmonium.cache.memoize"><code class="xref py py-func docutils literal notranslate"><span class="pre">memoize()</span></code></a> to
the line above the function definition. Per-function customizations go inside
the parens. For example,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">charmonium.cache</span> <span class="kn">import</span> <span class="n">memoize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@memoize</span><span class="p">()</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">squared</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;squaring </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squared</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">squaring 2</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squared</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
<p>Group-wide customizations are applied after definition through
<a class="reference internal" href="api_reference.html#charmonium.cache.MemoizedGroup" title="charmonium.cache.MemoizedGroup"><code class="xref py py-func docutils literal notranslate"><span class="pre">MemoizedGroup()</span></code></a>. For example, size is applied like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">charmonium.cache</span> <span class="kn">import</span> <span class="n">MemoizedGroup</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squared</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="n">MemoizedGroup</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="s2">&quot;100KiB&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="extra-state">
<h2>Extra State<a class="headerlink" href="#extra-state" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, language-level closures are not enough to track state. For this, the
user can supply <code class="docutils literal notranslate"><span class="pre">memoize(...,</span> <span class="pre">extra_function_state=callable_obj)</span></code>. The return
value of <code class="docutils literal notranslate"><span class="pre">callable_obj</span></code>. When it changes, then the cache for that function is
dropped. However, it is generally better to use <code class="docutils literal notranslate"><span class="pre">__cache_key__</span></code> and <code class="docutils literal notranslate"><span class="pre">__cache_ver__</span></code>
rather than <code class="docutils literal notranslate"><span class="pre">extra_function_state</span></code> (see <a class="reference internal" href="how_it_works.html#customizing-argument-keys"><span class="std std-ref">Customizing Argument Keys</span></a>).</p>
<p>State can be added to the whole system by <code class="docutils literal notranslate"><span class="pre">MemoizedGroup(...,</span>
<span class="pre">extra_system_state=callable_obj)</span></code>. The return value of <code class="docutils literal notranslate"><span class="pre">callable_obj</span></code> is a
part of the 1st match subkey. When it changes, the whole cache is dropped.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Time_to_live">Time-to-live</a> (TTL) is a common cache policy. For example, the memoized
function may be an API that you can call afresh every minute, but need to cache
it between those calls. TTL can easily be supported this way at either the
function or group-level by customizing <code class="docutils literal notranslate"><span class="pre">extra_function_state</span></code> and
<code class="docutils literal notranslate"><span class="pre">extra_system_state</span></code>. See <a class="reference internal" href="api_reference.html#charmonium.cache.TTLInterval" title="charmonium.cache.TTLInterval"><code class="xref py py-class docutils literal notranslate"><span class="pre">TTLInterval</span></code></a> for more
details.</p>
</section>
<section id="capturing-filesystem-side-effects">
<h2>Capturing Filesystem Side-Effects<a class="headerlink" href="#capturing-filesystem-side-effects" title="Permalink to this headline">¶</a></h2>
<p>Sadly, not all code is pure; many times, legacy code has impure side effects on
the filesystem. To make legacy code memoizable, the library has a
<a class="reference internal" href="api_reference.html#charmonium.cache.FileContents" title="charmonium.cache.FileContents"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileContents</span></code></a> helper. This class represents a
filepath <strong>and its contents</strong>.</p>
<p>Suppose we have the following impure function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">src</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">src_f</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">long_function</span><span class="p">(</span><span class="n">src_f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">src</span> <span class="o">+</span> <span class="s2">&quot;_copy&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst_f</span><span class="p">:</span>
        <span class="n">dst_f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="n">copy</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We can convert this to a pure function by:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@memoize</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">pure_copy</span><span class="p">(</span><span class="n">src</span><span class="p">:</span> <span class="n">FileContents</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FileContents</span><span class="p">:</span>
    <span class="c1"># FileContents acts like a string file-name</span>
    <span class="n">dst</span> <span class="o">=</span> <span class="n">src</span> <span class="o">+</span> <span class="s2">&quot;_copy&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Doing copy&quot;</span><span class="p">)</span>
    <span class="n">copy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dst</span>

<span class="c1"># The first time, we have to run the function</span>
<span class="c1"># This prints &quot;Doing copy&quot;</span>
<span class="n">pure_copy</span><span class="p">(</span><span class="n">FileContents</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">))</span>

<span class="c1"># The second time (if the file hasn&#39;t changed on the disk),</span>
<span class="c1"># @memoize emulates the file-system side-effects without running the function.</span>
<span class="c1"># This will not print &quot;Doing copy.&quot;</span>
<span class="n">pure_copy</span><span class="p">(</span><span class="n">FileContents</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">))</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="api_reference.html#charmonium.cache.FileContents" title="charmonium.cache.FileContents"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileContents</span></code></a> has a custom hash function that
includes a hash of its contents; if the <code class="docutils literal notranslate"><span class="pre">src</span></code> file changes, the hash
changes, and <cite>pure_copy</cite> is rerun.</p></li>
<li><p><a class="reference internal" href="api_reference.html#charmonium.cache.FileContents" title="charmonium.cache.FileContents"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileContents</span></code></a> has a custom de/serialization
includes the contents; when the memoization of <code class="docutils literal notranslate"><span class="pre">pure_copy</span></code> misses, it will
run the underlying <code class="docutils literal notranslate"><span class="pre">copy</span></code> and store the new contents of <code class="docutils literal notranslate"><span class="pre">dst</span></code>. When
memoization of <code class="docutils literal notranslate"><span class="pre">pure_copy</span></code> hits, it will deserialize those contents and
write them into <code class="docutils literal notranslate"><span class="pre">dst</span></code>, emulating the side-effect of <code class="docutils literal notranslate"><span class="pre">copy</span></code>.</p></li>
</ul>
</section>
<section id="usage-in-data-pipelines">
<h2>Usage in data pipelines<a class="headerlink" href="#usage-in-data-pipelines" title="Permalink to this headline">¶</a></h2>
<p>Naively, the entire input has to be hashed to retrieve or store a cached
result. This can be quite annoying, if your code operates on large dataframes or
numpy arrays. Instead, use a thunk which uniquely represents the data,</p>
<p>Suppose we have two functions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="s2">&quot;filename&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>We would write a memoization script like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">charmonium.cache</span> <span class="kn">import</span> <span class="n">memoize</span>

<span class="nd">@memoize</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># @memoizing g would have to hash the entire df.</span>

<span class="c1"># If the filename uniquely determines the contents of the df</span>
<span class="c1"># (e.g. the file is not changed between runs),</span>
<span class="c1"># then ideally, we should just use the filename and f&#39;s source code as a key to the cache.</span>
<span class="c1"># This can be done automatically by making new_g accept a &quot;thunk&quot; instead of accepting data.</span>

<span class="c1"># The type annotation is optional, but I will include it for clarity.</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Thunk</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>

<span class="nd">@memoize</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">df_thunk</span><span class="p">:</span> <span class="n">Thunk</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df_thunk</span><span class="p">()</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">df</span>

<span class="kn">import</span> <span class="nn">functools</span>
<span class="c1"># This is essentially lazy evaluation of f.</span>
<span class="n">df_thunk</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">&quot;filename&quot;</span><span class="p">))</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">df_thunk</span><span class="p">)</span>
<span class="c1"># If f&#39;s source code does not change, f(&quot;filename&quot;) will be reused.</span>
<span class="c1"># If f&#39;s and g&#39;s source code does not change, then g(df_thunk) will be reused.</span>
</pre></div>
</div>
</section>
<section id="adapting-old-code">
<h2>Adapting Old Code<a class="headerlink" href="#adapting-old-code" title="Permalink to this headline">¶</a></h2>
<p>Suppose you wish to speed up an application which makes usage of this function
called <code class="docutils literal notranslate"><span class="pre">work</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">work</span><span class="p">(</span><span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Memoization is most effective when the function is pure, so <code class="docutils literal notranslate"><span class="pre">work</span></code> needs to be
purified. This can be accomplished with minimal code change by creating a
<strong>wrapper function</strong> that maintains the same signature, but sets up a call to a
pure function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Old signature, new body</span>
<span class="k">def</span> <span class="nf">work</span><span class="p">(</span><span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">):</span>

    <span class="c1"># Defer to FileContents</span>
    <span class="n">real_input1</span> <span class="o">=</span> <span class="n">FileContents</span><span class="p">(</span><span class="n">input1</span><span class="p">)</span>

    <span class="c1"># Make a custom cache key (see `How It Works`)</span>
    <span class="n">input2</span><span class="o">.</span><span class="n">__cache_key__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="o">...</span>

    <span class="c1"># Turn global variables into parameters</span>
    <span class="n">input3</span> <span class="o">=</span> <span class="n">global_var</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">_real_work</span><span class="p">(</span><span class="n">real_input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">input3</span><span class="p">)</span>

    <span class="c1"># Trim off output side-effects</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># New signature, old body</span>
<span class="nd">@memoize</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_real_work</span><span class="p">(</span><span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">global_var</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="c1"># Load up side-effects into an object.</span>
    <span class="c1"># The object will be serialized into the cache now and deserialized whenever the function is called.</span>
    <span class="c1"># Deserializing should &quot;redo&quot; the side effect.</span>
    <span class="n">output_side_effect1</span> <span class="o">=</span> <span class="n">FileContents</span><span class="p">(</span><span class="s2">&quot;file_I_wrote.txt&quot;</span><span class="p">)</span>

    <span class="c1"># Append output side-effects</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">,</span> <span class="n">output_side_effect1</span>
</pre></div>
</div>
</section>
<section id="using-in-a-distributed-system">
<h2>Using in a distributed system<a class="headerlink" href="#using-in-a-distributed-system" title="Permalink to this headline">¶</a></h2>
<p>The library can be used to reuse results <em>between</em> machines, but you must
satisfy some invariants:</p>
<ul class="simple">
<li><p>Use a de/serialization “pickler” that will work between the platforms in
question. Consider OS, Python version, and library versions.</p></li>
</ul>
<ul>
<li><p>Use an <a class="reference internal" href="api_reference.html#charmonium.cache.ObjStore" title="charmonium.cache.ObjStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">ObjStore</span></code></a> that is accessible between the
machines in question. <a class="reference internal" href="api_reference.html#charmonium.cache.DirObjStore" title="charmonium.cache.DirObjStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">DirObjStore</span></code></a> is accessible
between machines if you provide a <a class="reference internal" href="api_reference.html#charmonium.cache.PathLike" title="charmonium.cache.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathLike</span></code></a>
object that is accessible between machines. For example, <a class="reference external" href="https://github.com/Quansight/universal_pathlib">Universal Pathlib</a>
provides a PathLike object representing an AWS S3 path or a GitHub path.</p></li>
<li><p>The object store should support atomic concurrent accesses to the same key.</p>
<ul class="simple">
<li><p>If there is a write-write race, it doesn’t matter which one wins, as long as
the write is atomic (not mangling together both writes). In theory, if all
the functions are pure, the two written values should deserialize to the
same object, although the binary representation may not be bit-equivalent.</p></li>
<li><p>If there is a read-write race, the reader should be able to see the value
before the writer or after, but not during. In theory, if all the functions
are pure, the pre-existing and newly-written value should deserialize to the
same object, although the binary representation may not be bit-equivalent.</p></li>
</ul>
</li>
<li><p>Use an appropriate lock. Without a lock, one could loose data in the
following. In the following example, even though <code class="docutils literal notranslate"><span class="pre">f(1)</span></code> and <code class="docutils literal notranslate"><span class="pre">f(2)</span></code> were
both computed, only one will be remembered.</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Time</p></th>
<th class="head"><p>Index on disk</p></th>
<th class="head"><p>Machine 1</p></th>
<th class="head"><p>Machine 2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>T1</p></td>
<td><p>{}</p></td>
<td><p>compute f(1); local index = {1: f(1)}</p></td>
<td><p>compute f(2); local index = {2: f(2)}</p></td>
</tr>
<tr class="row-odd"><td><p>T2</p></td>
<td><p>{}</p></td>
<td><p>read and merge index; local index = {1: f(1)} merged with {}</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>T3</p></td>
<td><p>{}</p></td>
<td><p>write index = {1: f(1)}</p></td>
<td><p>read and merge index; local index = {2: f(2)} merged with {}</p></td>
</tr>
<tr class="row-odd"><td><p>T4</p></td>
<td><p>{1: f(1)}</p></td>
<td></td>
<td><p>write index = {2: f(2)}</p></td>
</tr>
<tr class="row-even"><td><p>T4</p></td>
<td><p>{2: f(2)}</p></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>But with an appropriate lock,</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Time</p></th>
<th class="head"><p>Index on disk</p></th>
<th class="head"><p>Machine 1</p></th>
<th class="head"><p>Machine 2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>T1</p></td>
<td><p>{}</p></td>
<td><p>compute f(1); local index = {1: f(1)}</p></td>
<td><p>compute f(2); local index = {2: f(2)}</p></td>
</tr>
<tr class="row-odd"><td><p>T2</p></td>
<td><p>{}, locked by 1</p></td>
<td><p>read and merge index; local index = {1: f(1)} merged with {}</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>T3</p></td>
<td><p>{}, locked by 1</p></td>
<td><p>write index = {1: f(1)}</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>T4</p></td>
<td><p>{1: f(1)}</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>T5</p></td>
<td><p>{1: f(1)}, locked by 2</p></td>
<td></td>
<td><p>read and merge index; local index = {1: f(1), 2: f(2)}</p></td>
</tr>
<tr class="row-odd"><td><p>T6</p></td>
<td><p>{1: f(1), 2: f(2)}</p></td>
<td></td>
<td><p>write index</p></td>
</tr>
<tr class="row-even"><td><p>T7</p></td>
<td><p>{1: f(1), 2: f(2)}</p></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li><p>Consider setting fine-grain persistence
(<code class="docutils literal notranslate"><span class="pre">&#64;memoized(fine_grain_persistence=True)</span></code>). This writes the index after
every successful function call, so a processes can reuse work done by a
concurrent process. However, it will increase contention on the index lock.</p></li>
</ul>
</section>
<section id="using-the-cli">
<h2>Using the CLI<a class="headerlink" href="#using-the-cli" title="Permalink to this headline">¶</a></h2>
<p>There is a <a class="reference internal" href="cli.html"><span class="doc">CLI</span></a> as well. It can memoize UNIX or other commands from the
shell.</p>
</section>
<section id="debugging">
<h2>Debugging<a class="headerlink" href="#debugging" title="Permalink to this headline">¶</a></h2>
<p>There are two classes of bugs:</p>
<ul class="simple">
<li><p>Data is loaded from the cache when it shouldn’t be.</p></li>
<li><p>Data isn’t loaded from the cache when it should be. Generally this is more
prevalent; the code is quite good at detecting source-code changes, provided all
of the functions are pure.</p></li>
</ul>
<ol class="arabic">
<li><p>In either case, Try and isolate the problem to a minimal example, 1 or 2 function calls that triggers the undesirable behavior.</p></li>
<li><p>Then, turn on logging.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span><span class="o">,</span> <span class="nn">os</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;charmonium.cache.ops&quot;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">fh</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">FileHandler</span><span class="p">(</span><span class="s2">&quot;cache.log&quot;</span><span class="p">)</span>
<span class="n">fh</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">fh</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">))</span>
<span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Program </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
</pre></div>
</div>
</li>
<li><p>When you run the script, you should see a file <code class="docutils literal notranslate"><span class="pre">cache.log</span></code> containing lines
of JSON. Find the line containing <code class="docutils literal notranslate"><span class="pre">&quot;event&quot;:</span> <span class="pre">&quot;hit&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;event:&quot;</span> <span class="pre">&quot;miss&quot;</span></code>
for where <code class="docutils literal notranslate"><span class="pre">&quot;name&quot;</span></code> is equal to the function you are trying to memoize. Look
at the <code class="docutils literal notranslate"><span class="pre">&quot;obj_key&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;key&quot;</span></code> that the cache was trying to look up.</p></li>
</ol>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Program</span> <span class="mi">298881</span>
<span class="o">...</span>
<span class="p">{</span><span class="s2">&quot;event&quot;</span><span class="p">:</span> <span class="s2">&quot;miss&quot;</span><span class="p">,</span> <span class="s2">&quot;call_id&quot;</span><span class="p">:</span> <span class="mi">8476881272104231217</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;ascl_net_scraper.lib.scrape_index&quot;</span><span class="p">,</span> <span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="s2">&quot;1.2.6&quot;</span><span class="p">],</span> <span class="s2">&quot;ascl_net_scraper.lib.scrape_index&quot;</span><span class="p">,</span> <span class="mi">86185585044038137470190185817543203029</span><span class="p">,</span> <span class="mi">174330435704821325504748322645885609728</span><span class="p">,</span> <span class="mi">180438396020953764024835219690063154758</span><span class="p">],</span> <span class="s2">&quot;obj_key&quot;</span><span class="p">:</span> <span class="mi">204399087203688357111758696509623522761</span><span class="p">}</span>
<span class="o">...</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>See <cite>How It Works</cite> for details <code class="docutils literal notranslate"><span class="pre">&quot;key&quot;</span></code>; for now it will suffice to say it
is a five-tuple containing the system state, function name, function state,
arguments, and argument versions. These get hashed together to a single
object key that the cache will associate with this result.</p></li>
<li><p>If this misses but you think it should hit, search up to find that object key
in a prior run. There are three cases:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>It was computed, but got deleted by <code class="docutils literal notranslate"><span class="pre">&quot;event&quot;:</span> <span class="pre">&quot;evict&quot;</span></code>. You ran out of
space in the cache. This can be simply fixed by allocating a bigger one (see
“Group-wide customization” in <cite>How to Use</cite>).</p></li>
<li><p>It was computed, but got deleted by <code class="docutils literal notranslate"><span class="pre">&quot;event&quot;:</span> <span class="pre">&quot;cascading_delete&quot;</span></code>. This
can happen if there is a second call to the same function, but the function
state changed, or if there was an <code class="docutils literal notranslate"><span class="pre">&quot;event&quot;:</span> <span class="pre">&quot;index_read&quot;</span></code> which had a
different function state.</p>
<ul>
<li><p>If the function state changed, all old results may not be invalid. Let’s
figure out why the function state changed in the next step.</p></li>
<li><p>Index reads attempt to merge the index on disk with the index in RAM,
resolving conflicts by deferring to whichever <code class="docutils literal notranslate"><span class="pre">&quot;version&quot;</span></code> is newer
(greater). Let’s figure out why in the next step.</p></li>
</ul>
</li>
<li><p>It was never computed. If it was never computed, look for just the arguments
(4th and 5th) element of <code class="docutils literal notranslate"><span class="pre">&quot;key&quot;</span></code>. Perhaps the system changed between,
which would in turn, cause the <code class="docutils literal notranslate"><span class="pre">&quot;obj_key&quot;</span></code> to change. Let’s figure out why
that would change in the next step.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="6">
<li><p>If you are trying to figure out why a segment of the <code class="docutils literal notranslate"><span class="pre">&quot;key&quot;</span></code> takes a
particular value, see the <a class="reference external" href="https://github.com/charmoniumQ/charmonium.freeze/tree/main/README.rst#debugging">debugging help in charmonium.freeze</a>.</p></li>
</ol>
</section>
<section id="other-behaviors">
<h2>Other Behaviors<a class="headerlink" href="#other-behaviors" title="Permalink to this headline">¶</a></h2>
<p>By default, the index entry just holds an object key and the object store maps
that to the actual returned object. This level of indirection means that the
index is small and can be loaded quickly even if the returned objects are
big. If the returned objects are small, you can omit the indirection by setting
<code class="docutils literal notranslate"><span class="pre">memoize(...,</span> <span class="pre">use_obj_store=False)</span></code>.</p>
<p>By default, only the object size (not index metadata) is counted towards the
size of retaining an object, but if the object is stored in the index, the
object size will be zero.  then the metadata. Set <code class="docutils literal notranslate"><span class="pre">memoize(...,</span>
<span class="pre">use_metadata_size=True)</span></code> to include metadata in the size calculation. This is a
bit slower, so it is not the default.</p>
<p>By default, the cache is only culled to the desired size just before
serialization. To cull the cache after every store, set <code class="docutils literal notranslate"><span class="pre">memoize(...,</span>
<span class="pre">fine_grain_eviction=True)</span></code>. This is useful if the cache would run out of memory
without an eviction.</p>
<p>By default, the cache only stores a hash of the keys, which is faster and
smaller. Set <code class="docutils literal notranslate"><span class="pre">memoize(...,</span> <span class="pre">lossy_compression=False)</span></code> to store the whole keys
(useful for debugging).</p>
<p>Be aware of <code class="docutils literal notranslate"><span class="pre">memoize(...,</span> <span class="pre">verbose=True|False)</span></code>. If verbose is enabled, the
cache will emit a report at process-exit saying how much time was saved. This is
useful to determine if caching is “worth it.”</p>
<p>By default, I use the Greedy-Dual-Size Algorithm from [Cao et al.]_. This can be
customized by specifying <code class="docutils literal notranslate"><span class="pre">memoize(replacement_policy=YourPolicy())</span></code> where
<code class="docutils literal notranslate"><span class="pre">YourPolicy</span></code> inherits from <a class="reference internal" href="api_reference.html#charmonium.cache.ReplacementPolicy" title="charmonium.cache.ReplacementPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReplacementPolicy</span></code></a>.`</p>
<p>See <a class="reference internal" href="api_reference.html#charmonium.cache.Memoized" title="charmonium.cache.Memoized"><code class="xref py py-class docutils literal notranslate"><span class="pre">Memoized</span></code></a> and
<a class="reference internal" href="api_reference.html#charmonium.cache.MemoizedGroup" title="charmonium.cache.MemoizedGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoizedGroup</span></code></a> for details.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">charmonium.cache</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="cli.html">CLI</a></li>
<li class="toctree-l1"><a class="reference internal" href="how_it_works.html">How It Works</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors_guide.html">Contributor’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="works_cited.html">Works Cited</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="faq.html" title="previous chapter">Frequently Asked Questions</a></li>
      <li>Next: <a href="features.html" title="next chapter">Features</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;1980, Samuel Grayson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/tutorial.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>