:mod:`cache.util`
=================

.. py:module:: cache.util


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   cache.util.Pickler
   cache.util.PathLike
   cache.util.KeyGen
   cache.util.Constant
   cache.util.Sentinel
   cache.util.Future
   cache.util.GetAttr



Functions
~~~~~~~~~

.. autoapisummary::

   cache.util.pathlike_from



Attributes
~~~~~~~~~~

.. autoapisummary::

   cache.util.T
   cache.util.FuncParams
   cache.util.FuncReturn
   cache.util.PathLikeSubclass
   cache.util.PathLikeFrom


.. data:: T
   

   

.. data:: FuncParams
   

   

.. data:: FuncReturn
   

   

.. class:: Pickler

   Bases: :py:obj:`Protocol`

   Base class for protocol classes.

   Protocol classes are defined as::

       class Proto(Protocol):
           def meth(self) -> int:
               ...

   Such classes are primarily used with static type checkers that recognize
   structural subtyping (static duck-typing), for example::

       class C:
           def meth(self) -> int:
               return 0

       def func(x: Proto) -> int:
           return x.meth()

       func(C())  # Passes static type check

   See PEP 544 for details. Protocol classes decorated with
   @typing.runtime_checkable act as simple-minded runtime protocols that check
   only the presence of given attributes, ignoring their type signatures.
   Protocol classes can be generic, they are defined as::

       class GenProto(Protocol[T]):
           def meth(self) -> T:
               ...

   .. method:: loads(self, buffer)


   .. method:: dumps(self, obj)



.. data:: PathLikeSubclass
   

   

.. class:: PathLike

   Bases: :py:obj:`Protocol`

   Based on [pathlib.Path]

   [pathlib.Path]: https://docs.python.org/3/library/pathlib.html#pathlib.Path

   .. attribute:: name
      :annotation: :str

      

   .. method:: __truediv__(self, key)

      Joins a segment onto this Path.


   .. method:: read_bytes(self)


   .. method:: write_bytes(self, data)


   .. method:: mkdir(self, *, parents = ..., exist_ok = ...)


   .. method:: unlink(self, missing_ok = ...)


   .. method:: iterdir(self)


   .. method:: stat(self)


   .. method:: parent(self)
      :property:


   .. method:: exists(self)


   .. method:: resolve(self)



.. data:: PathLikeFrom
   

   

.. function:: pathlike_from(path)


.. class:: KeyGen

   Generates unique keys (not cryptographically secure).

   .. attribute:: key_bytes
      :annotation: :int

      

   .. attribute:: tolerance
      :annotation: :float

      

   .. attribute:: counter
      :annotation: :int = 0

      

   .. attribute:: key_space
      :annotation: :int = 0

      

   .. method:: __attrs_post_init__(self)


   .. method:: __iter__(self)


   .. method:: __next__(self)

      Generates a new key.


   .. method:: probability_of_collision(self, keys)

      Use to assert the probability of collision is acceptable.



.. class:: Constant(val)


   Bases: :py:obj:`Generic`\ [\ :py:obj:`FuncParams`\ , :py:obj:`FuncReturn`\ ]

   Abstract base class for generic types.

   A generic type is typically declared by inheriting from
   this class parameterized with one or more type variables.
   For example, a generic mapping type might be defined as::

     class Mapping(Generic[KT, VT]):
         def __getitem__(self, key: KT) -> VT:
             ...
         # Etc.

   This class can then be used as follows::

     def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
         try:
             return mapping[key]
         except KeyError:
             return default

   .. method:: __call__(self, *args, **kwargs)



.. class:: Sentinel


.. class:: Future(fulfill_twice = False)


   Bases: :py:obj:`Generic`\ [\ :py:obj:`T`\ ]

   Abstract base class for generic types.

   A generic type is typically declared by inheriting from
   this class parameterized with one or more type variables.
   For example, a generic mapping type might be defined as::

     class Mapping(Generic[KT, VT]):
         def __getitem__(self, key: KT) -> VT:
             ...
         # Etc.

   This class can then be used as follows::

     def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
         try:
             return mapping[key]
         except KeyError:
             return default

   .. method:: unwrap(self)


   .. method:: fulfill(self, value)



.. class:: GetAttr


   Bases: :py:obj:`Generic`\ [\ :py:obj:`T`\ ]

   When you want to getattr or use a default, with static types.

   Example: obj_hash = GetAttr[Callable[[], int]]()(obj, "__hash__", lambda: hash(obj))()

   .. attribute:: error
      

      

   .. method:: __call__(self, obj, attr_name, default = error, check_callable = True)



