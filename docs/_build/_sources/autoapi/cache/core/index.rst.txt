:mod:`cache.core`
=================

.. py:module:: cache.core


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   cache.core.MemoizedGroup
   cache.core.Memoized



Functions
~~~~~~~~~

.. autoapisummary::

   cache.core.memoize



Attributes
~~~~~~~~~~

.. autoapisummary::

   cache.core.__version__
   cache.core.BYTE_ORDER
   cache.core.LOCK_PATH
   cache.core.OBJ_STORE_PATH
   cache.core.DEFAULT_MEMOIZED_GROUP
   cache.core.GROUP_DEFAULT


.. data:: __version__
   :annotation: = 1.0.0

   

.. data:: BYTE_ORDER
   :annotation: :Final[str] = big

   

.. function:: memoize(**kwargs)


.. data:: LOCK_PATH
   :annotation: = .cache_lock

   

.. data:: OBJ_STORE_PATH
   :annotation: = .cache

   

.. class:: MemoizedGroup

   .. method:: __attrs_post_init__(self)



.. data:: DEFAULT_MEMOIZED_GROUP
   

   

.. data:: GROUP_DEFAULT
   

   

.. class:: Memoized

   Bases: :py:obj:`Generic`\ [\ :py:obj:`cache.util.FuncParams`\ , :py:obj:`cache.util.FuncReturn`\ ]

   Abstract base class for generic types.

   A generic type is typically declared by inheriting from
   this class parameterized with one or more type variables.
   For example, a generic mapping type might be defined as::

     class Mapping(Generic[KT, VT]):
         def __getitem__(self, key: KT) -> VT:
             ...
         # Etc.

   This class can then be used as follows::

     def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
         try:
             return mapping[key]
         except KeyError:
             return default

   .. attribute:: time_cost
      :annotation: :datetime.timedelta

      

   .. attribute:: time_saved
      :annotation: :datetime.timedelta

      

   .. method:: __attrs_post_init__(self)


   .. method:: print_usage_report(self)


   .. method:: return_val_pickler(self)
      :property:


   .. method:: enable_logging(self)


   .. method:: disable_logging(self)


   .. method:: __str__(self)

      Return str(self).


   .. method:: __call__(self, *args, **kwargs)


   .. method:: would_hit(self, *args, **kwargs)



